# Учебный компилятор

## Features

1. **Арифметически выражения** любой вложенности
с выполнением в соответствии с уровнями старшенства
    1. `*`, `/`, `%`
    2. `+`, `-`
2. **Логические выражения** любой вложенности
с выполнением в соответствии с уровнями старшенства
и операторы сравнения и проверки равенства
    1. `==`, `!=`, `>`, `>=`, `<`, `<=`
    2. `&&`
    3. `||`, `!!`
3. **Переменые** 
    1. `x := 5 * y`
    2. `z := x <= y`
4. **Операции ввода-вывода** (ввод и вывод осуществляется в стандартные потоки ввода и вывода: stdin, stdout)
    1. `x := read()`
    2. `write(x)`
5. **Условия** с альтернативным ветками (как конкретными, так и обобщенными)
    ```
    if x >= y && z then
        write(x)
    elif !z then
        write(y)
    else
        write(z) fi   
    ```
6. **Циклы while**
    ```
    while k > 0
    do
        res := res * n;
        k := k - 1
    od;
    ```
7. **Циклы for** с поддержкой составных условий и skip в предусловии
    ```
    for c := 2, c * c <= p && f, c := c + 1
    do
        f := p % c != 0
    od;
    ```
    ```
    for skip, n >= 1, n := n-1
    do
        f := f * n
    od;
    ```
8. **Фукнции**
    ```
    fun A (m, n)
    begin
        if m == 0 then return n+1
        elif m > 0 && n == 0 then return A (m-1, 1)
        else return A (m-1, A(m, n-1))
        fi
    end
    
    write (A (1, 21))
    ```
    
9. **Символы**
    1. `C := 'a'`

10. **Строки** и набор предопределенных функций для работы с ними:<br />
    `S := "I will remember April."`
    1. **strlen** - получение длины строки:<br />
        `strlen(S)` => `22`
    2. **strget** - получение заданного символа строки:<br />
        `strget(S, 2)` => `w`
    3. **strsub** - получение подстроки, начиная с символа n, длиной в k символов:<br />
        `strsub (S, 7, 8)` => `remember`
    4. **strdup** - копирование строки:<br />
        `strdup(S)` => `I will remember April.`,
    5. **strset** - задание i-го символа строки:<br />
        `strset(S, 4, 'j')` => `I wijl remember April.`,
    6. **strcat** - конкатенация двух строк:<br />
        `strcat(S, " It was very cold.")` => `I will remember April. It was very cold.`,
    7. **strcmp** - сравнение двух строк (сравнение осуществляется по кодам символов строк, слева направо):<br />
        `strcmp(S, "I wijl remember April.")` => `1`<br />
        `strcmp(S, "I wiz")` => `-1`<br />
        `strcmp(S, "I will")` => `-1`<br />
        `strcmp(S, "I will remember April.")` => `0`
    8. **strmake** - создание строки из n повторящихся символов:<br />
        `strmake (10, 'a')` => `aaaaaaaaaa`

11. **Массивы значений** (unboxed-массивы) и набор предопределенных функций для работы с ними:<br />
    1. **arrmake** - создание массива:<br />
        1. `S := arrmake (5)` => `[0, 0, 0, 0, 0]`
        2. `S := arrmake (5, 0)` => `[0, 0, 0, 0, 0]`
        3. `S := arrmake (5, [])` => `[0, 0, 0, 0, 0]`
        4. `S := arrmake (5, [1, 2, 3, 4, 5])` => `[1, 2, 3, 4, 5]`
    2. **arrlen** - получение длины массивы:<br />
        `arrlen(S)` => `5`
    4. Присвоение значения элементу массива по индексу:<br />
        `S[1] := 4` => `[0, 4, 0, 0, 0]`
    5. Получение значения элемента массива по индексу:<br /> 
        `write(S[1])` => `4`

11. **Массивы ссылок** (boxed-массивы) и набор предопределенных функций для работы с ними:<br />
    1. **Arrmake** - создание массива:<br />
        1. `S := Arrmake (5)` => `[nullptr, nullptr, nullptr, nullptr, nullptr]`
        2. `S := Arrmake (5, {})` => `[nullptr, nullptr, nullptr, nullptr, nullptr]`
        3. Присвоение со значением по умолчанию:<br />
            1. `S1 := arrmake (2, 1)` => `[1, 1]`
            2. `S2 := arrmake (2, 3)` => `[3, 3]`
            3. `S := Arrmake (2, {S1, S2})` => `[S1, S2]`
            4. `S2[1] := 4`
            5. `write(S[0][1])` => `1`
            6. `write(S[1][0])` => `3`
            7. `write(S[1][1])` => `4`
    2. **arrlen** - получение длины массивы:<br />
        `arrlen(S)` => `5`
    4. Присвоение ссылки элементу массива по индексу:<br />
        `S[1] := S1` => `[1, 1]`
    5. Получение значения элемента массива по индексу:<br /> 
        `write(S[1][0])` => `1`
        
## Реализация лексера

Лексер токенизирует код по набору регэкспов. Регэкспы задаются в файле `Lexer/tokenizer.py`.
Там перечислены все ключевые слова языка и шаблоны литералов, а также идентификаторов.

Помимо регэкспа можно задать левый и правый контексты, чтобы лексер выделял токены, соответствующие этому регэкспу, только в случае заданного окружения.<br />
Один из кейсов: контексты необходимы, чтобы ключевые слова языка не парсились как подстроки строк (либо других ключевых слов), а также для реализации строк и символов (у них левый и правый контексты - кавычки).

Пустые символы (пробелы, табуляция, переводы строк) и комментарии (комментарии используют `#`) игнорируются.

## Реализация парсера

### Парсер-комбинаторы

Самый верхний слой в архитектуре парсера - парсер-комбинаторы.

Они сочетают парсеры определенным образом (например, конкатенация парсеров; применение ф-ии над результатом парсера; применение парсера до тех пор, пока он не выйдет из строя и т. п.).

За счет возможности перегрузки операторов в Python некоторые из них записаны были как операторы, благодаря чему появилась возможность удобно и в красивом виде записывать грамматику прямо в языке (например: `parser1 + parser2`, `parser1 ^ func`, `parser1 | parser2` и т. п.).

Парсер-комбинаторы - основа для написания грамматики.

Парсер-комбинаторы находся в файле `Parser/combinators.py`.

1. **Result** - класс, описывающий результат работы парсера (значение + позиция в массиве токенов).
2. **Combinator** - базовый класс для всех комбинаторов, в нём описана перегрузка операторов на применение определенных комбинаторов.
3. **Reserved** - позволяет парсить токены с заданным значением и тегом (например, комбинатор позволит распарсить токен с тегом `RESERVED` и значением `if` - результат будет соответствовать ключевому слову языка `if`).
4. **Tag** - позволяет парсить токены с заданным тегом (например, комбинатор позволит распарсить идентификатор (например, имя переменной), если передать ему тэг `ID`).
5. **Concat**

### Парсеры

